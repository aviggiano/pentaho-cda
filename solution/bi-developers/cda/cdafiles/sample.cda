<?xml version="1.0" encoding="utf-8"?>
<CDADescriptor>

    <!-- DataSource definition. 
	
	Type controls what the datasource type is.
	The connection and query controls how the data is fetched. These values
	are specific to each access type

	-->
    <DataSources>
        <Connection id="1" type="sql.jdbc">
            <Driver>org.hsqldb.jdbcDriver</Driver>
			<Url>jdbc:hsqldb:mem:SampleData</Url>
            <User>sa</User>
            <Pass></Pass>
        </Connection>
        <Connection id="2" type="sql.jndi">
            <Jndi>SampleData</Jndi>
        </Connection>
        <Connection id="3" type="mondrian.jdbc">
            <Driver>org.hsqldb.jdbcDriver</Driver>
			<Url>jdbc:hsqldb:mem:SampleData</Url>
            <User>sa</User>
            <Pass></Pass>
			<Catalog>../../../steel-wheels/analysis/steelwheels.mondrian.xml</Catalog>
			<Cube>SteelWheelsSales</Cube>
        </Connection>
        <Connection id="4" type="mondrian.jndi">
			<Jndi>SampleData</Jndi>
			<Catalog>../../../steel-wheels/analysis/steelwheels.mondrian.xml</Catalog>
			<Cube>SteelWheelsSales</Cube>
        </Connection>
        <Connection id="5" type="olap4j.jdbc">
            <Driver>org.hsqldb.jdbcDriver</Driver>
			<Url>jdbc:hsqldb:mem:SampleData</Url>
            <User>sa</User>
            <Pass></Pass>
        </Connection>
        <Connection id="7" type="scripting.scripting">
            <Language>org.hsqldb.jdbcDriver</Language>
			<InitScript></InitScript>
        </Connection>
        <Connection id="8" type="metadata.metadata">
			<DomainId>steel-wheels</DomainId>
			<XmiFile>metadata.xml</XmiFile>
        </Connection>
    </DataSources>
    <!-- DataAccess object controls the query itself

	Access controls if the datasource can be seen from the outside or is to
	be used from a Compound datasource only

	-->
    <DataAccess id="1" connection="1" type="sql" access="public" cache="true" cacheDuration="300">
		<Name>Sql Query on SampleData - Jdbc</Name>
        <Query>
			select o.YEAR_ID, o.STATUS, sum(o.TOTALPRICE) as price from orderfact o
			where o.STATUS = ${status} and o.ORDERDATE &gt; ${orderDate}
			group by o.YEAR_ID, o.STATUS
		</Query>
        <!-- All parameters are passed as string from the outside. Their
		type is defined here. If needed, a conversion pattern must be specified

		Supported types: String, Date, Integer, Numeric
		-->
        <Parameters>
            <Parameter name="status" type="String" default="Shipped"/>
            <Parameter name="orderDate" type="Date" pattern="yyyy-MM-dd" default="2003-03-01"/>
        </Parameters>
        <!-- 
		Columns block allow specifying name and CalculatedColumn the creation of new
		columns based on formulas
		-->
		<Columns>
			<Column idx="0">
				<Name>Year</Name>
			</Column>
			<CalculatedColumn>
				<Name>PriceInK</Name>
				<Formula>=[PRICE]/1000000</Formula>
			</CalculatedColumn>
		</Columns>
        <!-- Settings block here overrides defaults and general settings -->
        <Settings>
            <Export type="csv" includeTotals="true">
                <Column idx="0" aggregator="None"/>
                <Column idx="1" aggregator="Average"/>
            </Export>
        </Settings>
        <!-- Output controls what is outputed and by what order. Defaults to everything -->
        <Output indexes="1,0,2,3"/>
    </DataAccess>
    <DataAccess id="2" connection="2" type="sql" access="public" cache="true" cacheDuration="3600">
		<Name>Sql Query on SampleData - Jndi</Name>
        <Query>
			select o.YEAR_ID, o.STATUS, sum(o.TOTALPRICE) as price from orderfact o
			where o.STATUS = ${status} and o.ORDERDATE &gt; ${orderDate}
			group by o.YEAR_ID, o.STATUS
		</Query>
        <!-- All parameters are passed as string from the outside. Their
		type is defined here. If needed, a conversion pattern must be specified

		Supported types: String, Date, Integer, Numeric
		-->
        <Parameters>
            <Parameter name="status" type="String" default="Shipped"/>
            <Parameter name="orderDate" type="Date" pattern="yyyy-MM-dd" default="2004-03-01"/>
        </Parameters>
        <!-- 
		Columns block allow specifying name and CalculatedColumn the creation of new
		columns based on formulas
		-->
		<Columns>
			<Column idx="0">
				<Name>Year</Name>
			</Column>
			<CalculatedColumn>
				<Name>PriceInK</Name>
				<Formula>=[PRICE]/1000000</Formula>
			</CalculatedColumn>
		</Columns>
        <!-- Settings block here overrides defaults and general settings -->
        <Settings>
            <Export type="csv" includeTotals="true">
                <Column idx="0" aggregator="None"/>
                <Column idx="1" aggregator="Average"/>
            </Export>
        </Settings>
        <!-- Output controls what is outputed and by what order. Defaults to everything -->
        <Output indexes="1,0,2,3"/>
    </DataAccess>
    <DataAccess id="3" connection="3" type="mdx" access="public">
		<Name>Mdx Query on SampleData - Jdbc</Name>
        <Query>
			select {[Measures].[Sales]} ON COLUMNS,
			NON EMPTY  [Time].Children ON ROWS
			from [SteelWheelsSales]
			where ([Order Status].[${status}])
		</Query>
        <Parameters>
            <Parameter name="status" type="String" default="In Process"/>
        </Parameters>
		<Columns>
			<Column idx="1">
				<Name>Year</Name>
			</Column>
			<Column idx="2">
				<Name>price</Name>
			</Column>
			<CalculatedColumn>
				<Name>PriceInK</Name>
				<Formula>=[price]/1000000</Formula>
			</CalculatedColumn>
		</Columns>
    </DataAccess>
    <DataAccess id="4" connection="4" type="mdx" access="public">
		<Name>Mdx Query on SampleData - Jndi</Name>
        <Query>
			select {[Measures].[Sales]} ON COLUMNS,
			NON EMPTY  [Time].Children ON ROWS
			from [SteelWheelsSales]
			where ([Order Status].[${status}])
		</Query>
        <Parameters>
            <Parameter name="status" type="String" default="Shipped"/>
        </Parameters>
		<Columns>
			<Column idx="1">
				<Name>Year</Name>
			</Column>
			<Column idx="2">
				<Name>price</Name>
			</Column>
			<CalculatedColumn>
				<Name>PriceInK</Name>
				<Formula>=[price]/1000000</Formula>
			</CalculatedColumn>
		</Columns>
    </DataAccess>
    <DataAccess id="5" connection="3" type="denormalizedMdx" access="public">
		<Name>Denormalized Mdx Query on SampleData - Jdbc</Name>
        <Query>
			select {[Measures].[Sales]} ON COLUMNS,
			NON EMPTY  [Time].Children ON ROWS
			from [SteelWheelsSales]
			where ([Order Status].[${status}])
		</Query>
        <Parameters>
            <Parameter name="status" type="String" default="Shipped"/>
        </Parameters>
    </DataAccess>
    <DataAccess id="6" connection="4" type="denormalizedMdx" access="public">
		<Name>Denormalized Mdx Query on SampleData - Jndi</Name>
        <Query>
			select {[Measures].[Sales], [Measures].[Quantity]} ON COLUMNS,
			NON EMPTY  [Time].Children ON ROWS
			from [SteelWheelsSales]
			where ([Order Status].[${status}])
		</Query>
        <Parameters>
            <Parameter name="status" type="String" default="Shipped"/>
        </Parameters>
		<Columns>
			<CalculatedColumn>
				<Name>MeasureInK</Name>
				<Formula>=[Measure]/1000000</Formula>
			</CalculatedColumn>
		</Columns>
    </DataAccess>
    <DataAccess id="7" connection="5" type="olap4J" access="public">
		<Name>Olap4J on SampleData - Jdbc</Name>
        <Query>
			select {[Measures].[Sales]} ON COLUMNS,
			NON EMPTY  [Time].Children ON ROWS
			from [SteelWheelsSales]
			where ([Order Status].[${status}])
		</Query>
        <Parameters>
            <Parameter name="status" type="String" default="Shipped"/>
        </Parameters>
	</DataAccess>
	<DataAccess id="8" connection="8" type="mql" access="public">
		<Name>Mql on SampleData - Metadata</Name>
		<Query><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
			<mql>
				<domain_type>relational</domain_type>
				<domain_id>steel-wheels</domain_id>
				<model_id>BV_ORDERS</model_id>
				<model_name>Orders</model_name>
				<selections>
					<selection>
						<view>CAT_ORDERS</view>
						<column>BC_ORDERS_ORDERDATE</column>
					</selection>
					<selection>
						<view>CAT_ORDERS</view>
						<column>BC_ORDERS_ORDERNUMBER</column>
					</selection>
					<selection>
						<view>CAT_ORDERS</view>
						<column>BC_ORDER_DETAILS_QUANTITYORDERED</column>
					</selection>
				</selections>
				<constraints>

					<constraint>
						<operator>AND</operator>
						<condition>[CAT_ORDERS.BC_ORDERDETAILS_QUANTITYORDERED] &gt;70</condition>
					</constraint>

					<constraint>
						<operator>AND</operator>
						<condition>[CAT_ORDERS.BC_ORDERS_ORDERDATE] &gt; DATE(2003;12;31)</condition>
					</constraint>
				</constraints>
				<orders/>
			</mql>]]>
		</Query> 
		<Parameters>
			<Parameter name="status" type="String" default="Shipped"/>
		</Parameters>
	</DataAccess>
	<!-- CompoundDataAccess can be used to join queries. Some types are
	supported, and the user is responsible for assuring the different dataaccess
	are compatible:

	* Union: Appends different sources
	* Join: Joins 2 resultsets based on one or more keys. Results have to be 
	sorted by those keys.

	-->
	<!--CompoundDataAccess id="3" type="union">
	<Source id="1"/>
	<Source id="2"/>
</CompoundDataAccess>
<CompoundDataAccess id="4" type="join">
	<Left keys="0"/>
	<Right keys="0"/>
	<Output indexes="0,2,3"/>
</CompoundDataAccess-->
</CDADescriptor>
